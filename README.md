## 리눅스
* 사용자는 리눅스 커널과 통신하기 위해 리눅스 쉘사용. 정확히는 커널과 운영체제를 이어주는 것
* 터미널은 하나의 프로세스이고 명령어 실행은 해당 터미널의 정보를 기준으로 백그라운드에 자식프로세스가 fork되어 명령어 실행된다. 즉 터미널에서 ‘ls’라는 명령어를 입력하면 자식프로세스 1개가 fork되어 백그라운드에서 부모프로세스의 정보를 기준으로 해당 명령어 즉, stdin을 통해 정보를 입력받고 stdout을 통해 ls명령어를 호출한 터미널로 정보를 반환하는 식으로 동작

### 커널
* 메모리에 상주하는 운영체제의 부분, 주로 디바이스 관리, 프로세스 관리, 메모리 관리, 시스템 콜 제공과 같은 기능을 가지고 있다. 쉽게 말해 컴퓨터 자원을 관리한다.

### 파일 디스크립터:

* 유닉스에서는 기본적으로 입력을 터미널 키보드와 연결시키고 출력을 터미널 디스플레이와 연결시킨다.

유닉스는 키보드와 모니터를 포함항여 컴퓨터의 모든 것을 파일로 모델링하는 것으로 유명하다. 따라서 디스플레이에 데이터를 쓰는 것은 스크린 위에 데이터 디스플레이를 담당하는 어떤 파일에 데이터를 쓰는 것이다.

비슷하게 키보드에서 데이터를 읽어오는 것은 키보드를 나타내는 어떤 파일에서 데이터를 읽어오는 것이다. 데이터는 바이트를 한 곳에서 다른 곳으로 전송하는 스트림을 통해 흐른다.
  
* 3가지의 디폴트 입출력 스트림들이 있다.

stdin, stdout, stderr이다. 이 스트림틀은 각자 특정한 파일 디스크립터를 갖고 있다. 각 파일 디스크립터는 어떤 정수 값인데 그것은 어떤 하나의 오픈파일과 연결되어 있다. 

그리고 프로세스들은 파일 디스크립터를 이용해 데이터를 처리한다. 그 3가지의 기본 스트림들은 다음과 같은 파일 디스크립터 숫자를 갖고 있다. stdin=0, stdout=1, stderr=2. 이 파일 디스크립터들은 어떤 하나의 파일 디스크립터 테이블에 저장되어 있다. 그리고 각 프로세스는 자신만의 파일 디스크립터 테이블을 갖고 있으며, 프로세스가 생성될 때 기본적으로 0,1 그리고 2가 해당하는 스트림들에게 각각 맵핑된다. 

각 스트림은 자신에게 맵핑된 파일 디스크립터에겍 보낸 데이터가 어디로 가는지 또는 그 파일 디스크립터로부터 받은 데이터가 어디로부터 오는지 알 지 못한다. 스트림은 자신의 파일 디스크립터를 통햏 데이터를 처리할 뿐 실제 데이터 리소스를 직접 처리하는 것이 아니다. 

따라서 프로세스는 파일 디스크립터들만 처리하면 되고 실제 그 파일을 처리하지는 않는다. 대신 커널이 안전하게 그 파일을 관리한다. 그리고 프로세스는 0,1,2 이외에도 다른 파일 디스크립터를 사용하게 되는데, 새로운 파일 디스크립터가 할당될 때는 가장 낮은 숫자의 아직 사용되지 않은 파일 디스크립터가 사용된다. 따라서 0,1,2가 디폴트로 설정된 이후에 다음으로 사용될 파일 디스크립터는 3이다.

### 데이터 흐름:
* 터미널에서 어떤 명령을 실행시킬 때는 입력과 출력이 적절하게 처리되어야 한다.

각 명령은 어떤 데이터를 입력으로 받아야 할지 그리고 어떤 데이터를 출력으로 내보내야 할지를 알아야 한다.

키보드는 명령을 수행하는 프로그램에게 데이터를 전달하고(명령어 입장ㅇ에서는 stdin을 통해 입력을 받는다) 그 프로그램은 stdout을 통해 터미널에게 데이터를 출력한다. 각 입력과 출력에 대응되는 파일 옆에는 파일 디스크립터 번호가(0,1) 있다. 

일반적으로 데이터가 어떤 곳으로 흘러들어가는 것을 입력이라고 하며, 데이터가 어떤 곳으로 부터 흘러나가는 것을 출력이라고 한다.

* 터미널로 데이터를 출력할 수 있는 스트림은 기본적으로 2가지라는것이다 (stdout, stderr)

stderr스트림은 어떤 명령을 실행시킬 때 오류가 있을 경우 사용된다. 

예를 들어 존재하지 않는 디렉토리의 컨텐츠를 리스트하려고 하면 에러가 발생하고 에러를 출력하기 위해 사용된 스트림은 사실 stderr이며, stdout이 아니다. 따라서 stderr또한 기본적으로 터미널에 출력하기 때문에 오류 메세지를 터미널에서 볼 수 있다.

'''
  test-Jaeho:~ Jaeho$ ls testdirect
  ls: testdirect: No such file or directory
'''

* 몇몇 명령들은 입력 출력 모두 사용한다. 둘 중 하나만 사용하거나 아예 사용하지 않는 것도 있다.

우선 입력의 진정한 의미에 대해서 알아보자 쉘 입장에서 봤을 때는 키보드로 입력되는 모든 것이 입력인 것이다. 하지만 우리는 좀 더 구체적으로 명령을 처리하는 프로세스가 파일들로부터 데이터를 주고받기 위해서 명령들에게 필요한 입력과 출력에 대해 알아보자. 

명령의 옵션인자들은 커맨드 라인으로부터 읽히는데 비해서 실제 입력은 파일 디스크립터와 연결된 오픈파일로 부터 읽힌다. 따라서 입력은 stdin을 이용해 전달된 데이터 그리고 그 입력이 키보드를 통해서 입력되었는지, I/O 리다이렉션을 통해 리다이렉트되었는지, 또는 명령에게 파일인자로 전달되었는지 상관없이 어떤 파일인자가 명령에 전달되었을 때 프로세스가 실질적으로 그 파일의 컨텐츠를 읽거나 변경할 경우 그것을 입력으로 생각할 것이다.  하지만 단순히 그 파일을 참조하는 경우에는 입력으로 간주 하지 않는다. 

* 입력은 없지만 출력은 있는 명령의 한 예로 ls명령을 생각할 수 있으며 익것은 현재 디렉토링에 있는 모든 파일과 디렉토리를 나열한다.
 
만약 어떤 명령이 stdin으로 부터 입력을 받지 않는다면 그 명령으로 전달되는 데이터는 그 명령을 실행하는 프로그램에 의해 무시될 것이다. 왜냐하면 그 명령은 입력 데이터를 처리하도록 만들어지지 않았기 때문이다.

예를 들어 < wrods.txt ls를 입력하면 이것은 현재 디렉토리 안의 모든 파일과 디렉토리를 출력하고 stdin으로 리다이렉트된 입력 데이터는 무시할 것이다.

* 입력은 없지만 출력은 없는 명령 

* 한 예로 mv 명령을 생각할 수 있으며 이것은 파일을 이동시키거나 이름을 바꾸는데 사용된다. 내가 그 명령에게 이동시키거나 이름을 바꾸려고 하는 파일 또는 디렉토리의 이름 정확히 전달하면 stdout 또는 stderr 통해 출력 데이터는 없다. 전달되는 파일의 컨텐츠가 읽히거나 또는 사용되는 것이 아니기 때문에 전달된 파일은 입력이 아니다.

* 입력과 출력을 모두 사용하는 명령

* 이거에 대한 예제로 sort명령이 있다. 만약 파일 인자와 입력 리다이렉션이 둘 다 없을 경우 터미널은 사용자가 정렬할 스트링을 입력할 때까지 대기한다. 그리고 사용자가 Ctrl-D를 입력하면(sort프로세스의 stdin과 키보드를 연결하는 커뮤니케이션채널의 쓰기 엔드(write end)종료) 그 sort명령을 실행하는 프로세스는 필요한 스트링이 전부 입력되었다고 생각할 것이다. 

'''
  test-Jaeho:~ Jaeho$ sort
  bear
  cobra
  abrams
  zero
  abrams
  bear
  cobra
  zero

'''
그러므로 그 입력된 스트링들은 stdin을 통해 명령을 실행하는 프로세스에게 전달되고 그 프로세스에 의해 정렬된 후 stdout을 통해 터미널에게 출력된다. sort명령은 또한 사용자에게 직접 스트링을 받지 않고 파일 이름을 인자로 받아 그 파일 안의 스트링을 입력으로 사용할 수 있다. 이것은 아까 말한 입력의 정의를 만족하는데 왜냐하면 그것은 파일이면서 sort -r과 같은 옵션인자가 아니기 때문에다. 게다가 sort명령은 리다이렉션을 통해서도 입력을 전달받을 수 있다. 

### 버퍼:
* 입출력 전송 속도차이에 대한 성능을 보완하기 위해 사용. 입력속도에 비해 출력 속도가 느린경우 데이터를 임시 저장하는 공간을 말하며 임시저장장치라고도 한다.

* 버퍼를 사용하면 운영체제의 API 호출 횟수를 줄여 입출력 성능을 개선하게 된다. 스트림과 버퍼는 항상묶여다니는게 좋을것 같지만 빠른 반응이 요구되는 게임과 프로그램에서는 버퍼를 사용할 경우반응이 느릴수 있다.

### 리눅스 파이프:
파이프는 데이터가 한 프로세스에서 다른 프로세스로 전달되도록 하는데(일방향의 데이터 흐름을 통해서), 그로인해 프로세스들의 명령들이 스트림에 의해 서로 연결된다. 이것은 여러 명령들이 함께 동작하여 더 큰 목적을 달성할 수 있도록 해준다. 

이러한 프로세스들의 체이닝은 파이프라인으로 표현될 수 있다. 한 파이프라인 안에 있는 명령들은 서로 파이프에 의해서 연결되며 파이프의 한 쪽 끝에서 다른 쪽 끝으로 데이터가 흐르면서 두 프로세스 사이에 데이터가 공유된다. 이 때 파이프라인 안에 있는 각 명령들은 각자 독립적인 프로세스 안에서 실행되며, 각자 독립적인 메모리 공간에서 실행된다. 그러므로 우리는 각 프로세스들이 서로 통신할 수 있는 방법이 필요하게 되는데, 바로 pipe() 시스템 호출이 그 방법을 제공한다. 

구현에 있어서 사실 파이프는 그저 버퍼된 스트림에 불과하며 그 스트림은 2개의 파일 디스크립터와 연결되어 있는데 첫 번째는 데이터를 읽기위한 것이고, 두 번째는 데이터에 쓰기 위한 것이다. 더욱 구체적으로, 파이프라인의 명령의 실행을 처리하는 코드를 살펴보면, 2개의 정수값을 저장하는 배열이 생성되고, pipe()호출은 그 배열에 사용 가능한 2개의 파일 디스크립터 값을(일반적으로 사용가능한 가장 낮은 숫자의 2개의 파일 디스크립터를 사용한다)채운다. 

우리는 한 프로세스에서 시작되는 데이터 스트림을 독립된 공간에 들어있는 물이라고 생각할 수 있다. 그리고 그 물이 다음 프로세스의 공간으로 흐를 수 있는 유일한 방법은 각 공간을 파이프로 연결하는 것이다. 이러한 방식으로, 그 물(데이터)는 첫 번째 공간(프로세스)에서 파이프로 흘러들어가고, 파이프 안에 물이 가득차면, 다시 그 파이프에서 다음 공간(프로세스)으로 물(데이터)을 흘려보낸다.

(sort | grep ea) -> 기본적으로 sort명령은 사용자가 stdin을 통해서 입력을 전달할 때까지 기다린 다음 입력받은 스트링들은 알파벳 순서대로 정렬되고, 그 정렬된 결과가 stdout을 통해서 파이프로 전달된다. 이것은 stdout으로 하여금 출력된 데이터를 터미널 디스플레이가 아니라 파이프의 왼쪽 끝으로 입력하도록 만듦으로써 가능해진다. 

각 프로세스는 자신만의 파일 디스크립터 테이블을 갖는다는 것이다. 파이프라인의 각 명령은 각자 독립적인 프로세스 안에서 실행되기 때문에 각 명령은 자신만의 버전의 파일 디스크립터를 갖고 있으며, 자신만의 stdin, stdout, stderr를 갖고 있다. 이것이 의미하는 것은 위의 다이어그램에서 왼쪽 끝에 있는 1과는 다른 파일 디스크립터 테이블 안에 있는 것이고, 그것은 grep명령을 실행하는 프로세스에 속하는 것이다. 하지만 스트림들은 프로세스 바운더리를 건너 데이터를 전송하도록 설정되어 있기 때문에 데이터가 파이프라인을 타고 잘 전달된다면 결과적으로 데이터는 마지막 프로세스로 전달될 것이다.

다시 처음부터 살펴보면 sort명령은 정렬된 스트링 리스트를 출력(output)으로 갖게되고, 그 출력 데이터를 결과적으로 다음 프로세스(grep)에게 전달하기 위해서, 생성된 파이프에게 출력 데이터를 전달해야 한다. 데이터는 sort프로세스로부터 파이프로 전달되고 그것은 다시 파이프로부터 grep프로세스로 전달된다. 이제 pipe호출에 의해 전달된 파일 디스크립터에 대해 알아보자 파이프라인에서 명령들을 실행하는 코드 안에서, pipe호출은 파일 디스크립터 배열을 채우게 되고 따라서 파일 디스크립터 4에 쓰여진 데이터가 파일 디스크립터 3으로부터 읽히도록 만든다.  

배열 속에 들어가는 값들은 오직 프로세스에게만 중요하다. 하지만 각 파일 디스크립터의 용도는 데이터에게 있어 매우 중요하다. 그리고 각 파일 디스크립터의 용도는 배열안에서 몇 번째 인덱스에 위치하느냐에 따라서 결정된다. 그리고 여기에서 알아야 할 매우 중요한 개념이 있는데 다이어그램들은 데이터가 왼쪽에서 오른쪽으로 흐르는 모델이라는 것을 잘 생각해보자. 파일 디스크립터는 배열안에서 설정되어 4에 쓰여진 데이터가 3에서 읽히도록 된다. 하지만 왜 4가 왼쪽으로 가고 3이 오른쪽으로 갈까. 

여기서 핵심적인 내용은 바로 pipe호출에 의해 설정되는 읽기 쓰기 액션은 바로 파이를 사용하는 양쪽2개의 프로세스들의 관점에서 정의된다는 것이다. 따라서 pipe호출에 4를 writable end로 설정하면 그것은 첫 번째 명령(sort)의 프로세스가 출력(output)을 쓰기(write)하는 파이프의 입력(input)을 전달받는 파이프의 왼쪽 파일 디스크립터가 되는 것이다. 반대로 pipe()호출에 3을 readable end로 설정하면 그 것은 두 번째 명령(grep)의 프로세스가 입력(input)을 읽기(read)하는 파이프의 출력을 전달하는 파이프의 오른쪽 파일 디스크립터가 되는것이다.

따라서 데이터는 첫 번째 프로세스(sort)에서 파이프로 전달되고, 파이프는 모든 데이터가 전달될 때까지 기다렸다가 모든 데이터가 전달되면 파이프는 그 다음 프로세스(grep)로 그 데이터를 보낸다. 그리고 마지막으로 파이프로부터 데이터를 전달받은 grep명령을 실행하는 프로세스는 그 입력 데이터중에서 ‘ea’가 포함된 라인을 stdout으로 출력하여 터미널로 내보내게 된다. 
